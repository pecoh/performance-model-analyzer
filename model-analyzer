#! /usr/bin/env python3

import argparse
import json
import math
import sys

def parseArgs():
	"""Define the options of the model-analyzes, parse the command line, and return the options object."""
	optionsParser = argparse.ArgumentParser()
	optionsParser.add_argument('files', type=argparse.FileType('r'), nargs='+', help="one or more files describing the jobs and machine model")

	return optionsParser.parse_args()

def throws(code) -> bool:
	"""Turn an exception into a boolean.

	code should be some lambda that doesn't take arguments."""
	try:
		code()
		return False
	except:
		return True

def swallowExceptions(code):
	"""Execute possibly throwing code, and either return its result or None."""
	try:
		return code()
	except:
		return None

def div(a: float, b: float) -> float:
	"""Implement correct division without throwing exceptions."""
	try:
		return a/b
	except:
		return a*math.copysign(math.inf, b)

assert div(1e-300, 1e-300) == 1
assert div(1e-300, -1e-300) == -1
assert div(-1e-300, 1e-300) == -1
assert div(-1e-300, -1e-300) == 1
assert div(1, 0) > 1e300
assert div(1, -0.0) < -1e300
assert div(-1, 0) < -1e300
assert div(-1, -0.0) > 1e300
assert math.isnan(div(0, 0))
assert math.isnan(div(0, -0.0))
assert math.isnan(div(-0.0, 0))
assert math.isnan(div(-0.0, -0.0))

class ResourceObject:
	"""A simple data object that contains the variables throughput, availableThroughput, timeshared, and paths.
	throughput is the capacity of the resource, availableThroughput is the amount of it that is not already committed to a job.
	timeshared has the same meaning as the flag in the data model, and is always present.
	paths is a dictionary of child resources, which may also contain a ".." entry for the parent resource.
	Subresources are only reachable from their parent if they have a multiplicity of 1."""
	def __init__(self, resourceDescription: dict, parent = None, subresourceName = None):
		self.throughput = swallowExceptions(lambda: resourceDescription["throughput"])
		self.availableThroughput = self.throughput
		self.timeshared = swallowExceptions(lambda: resourceDescription["timeshared"]) or False
		self.paths = dict()
		if parent:
			self.paths[".."] = parent
			if not swallowExceptions(lambda: resourceDescription["multiplicity"] != 1):
				parent.paths[subresourceName] = self

	def printTree(self, indentation = 0, caller = None):
		"""For debugging purposes, only."""
		print("{")
		indentation += 1
		for name in self.paths:
			print("\t"*indentation + name + ": ", end="")
			if self.paths[name] == caller:
				print("...")
			else:
				self.paths[name].printTree(indentation, self)
		indentation -= 1
		print("\t"*indentation + "}")

class AbstractResource:
	"""A simple data object that provides a means to parse a path to the ResourceObjects.
	Unlike ResourceObject, these do not store throughputs,
	abstract subresources are always reachable from their parent,
	and the timeshared ones provide a list of resourceObjects, which must be filled by the caller."""
	def __init__(self, resourceDescription: dict, parent = None, subresourceName = None):
		if swallowExceptions(lambda: resourceDescription["timeshared"]):
			self.resourceObjects = list()
		self.paths = dict()
		if parent:
			self.paths[".."] = parent
			parent.paths[subresourceName] = self

	def addConcrete(self, concrete: ResourceObject):
		"""Noop if the resource is not timeshared."""
		if hasattr(self, "resourceObjects"):
			self.resourceObjects.append(concrete)

	def hasConcrete(self):
		"""Check if there are any ResourceObjects connected to this abstract resource."""
		return swallowExceptions(lambda: len(self.resourceObjects))

	def printTree(self, indentation = 0):
		"""For debugging purposes, only."""
		print("{")
		indentation += 1
		if hasattr(self, "resourceObjects"):
			print("\t"*indentation + "%d concrete resources: "%len(self.resourceObjects), end="")
			self.resourceObjects[0].printTree(indentation)
		else:
			print("\t"*indentation + "no concrete resources")
		for name in self.paths:
			if name == "..":
				print("\t"*indentation + name)
			else:
				print("\t"*indentation + name + ": ", end="")
				self.paths[name].printTree(indentation)
		indentation -= 1
		print("\t"*indentation + "}")

def resolvePath(root: ResourceObject or AbstractResource, path: list) -> ResourceObject or AbstractResource:
	for i in range(len(path)):
		root = swallowExceptions(lambda: root.paths[path[i]])
	return root

def relativatePath(referencePath: list, absolutePath: list) -> list:
	prefixLength = 0
	suffixLength = len(referencePath)
	for i in range(suffixLength):
		if not swallowExceptions(lambda: referencePath[i] == absolutePath[i]):
			break
		prefixLength += 1
		suffixLength -= 1
	return [".." for i in range(suffixLength)] + absolutePath[prefixLength:]

assert relativatePath(["foo", "bar", "baz"], ["bim"]) == ["..", "..", "..", "bim"]
assert relativatePath(["foo", "bar", "baz"], ["foo", "bim"]) == ["..", "..", "bim"]
assert relativatePath(["foo", "bar", "baz"], ["foo", "bar", "bim"]) == ["..", "bim"]
assert relativatePath(["foo", "bar", "baz"], ["foo", "bar", "baz", "bim"]) == ["bim"]

class Model:
	def __init__(self, files):
		#read the files
		modelDescription = dict()
		for f in files:
			modelDescription.update(json.load(f))

		#check for completeness
		if throws(lambda: modelDescription["resources"]):
			sys.exit("error: no resources defined")
		if throws(lambda: modelDescription["job definitions"]):
			sys.exit("error: no job descriptions defined")
		if throws(lambda: modelDescription["jobs"]):
			sys.exit("error: no jobs found")
		self.resources = modelDescription["resources"]
		self.definitions = modelDescription["job definitions"]
		self.jobs = modelDescription["jobs"]

		#add progress vars to the jobs
		for key in self.jobs:
			self.jobs[key]["progress"] = 0.0
			self.jobs[key]["done"] = False

		#sort the jobs into executable and waiting jobs
		self.classifyJobs()

		#Build the DAG of concrete resource objects, this adds a "resource objects" entry to the timeshared resources,
		#which is an array of resource description dictionaries.
		self.resources = self.createResourceObjects(self.resources, AbstractResource(None), ResourceObject(None))
		#self.resources.printTree()

		#Scan the job descriptions for paths to timeshared resources, and make all other resource paths relative to those.
		#Also, find the maximum resource request.
		self.maxRequest = 0
		for name in self.definitions:
			resourceList = swallowExceptions(lambda: self.definitions[name]["resources"])
			if not resourceList: sys.exit("error: job definition '" + name + "' does not require any resources")
			timesharedIndices = [i for i in range(len(resourceList)) if swallowExceptions(lambda: resolvePath(self.resources, resourceList[i]["path"]).hasConcrete())]
			if len(timesharedIndices) != 1:
				print("error: job definition '" + name + "' does not name exactly one timeshared resource")
				print("found %d paths to timeshared resources:"%len(timesharedIndices))
				for i in timesharedIndices:
					print("\t" + "/".join(resourceList[i]["path"]))
				sys.exit("exiting due to fatal error")
			timesharedIndex = timesharedIndices[0]

			#Remove the timeshared resource from the list of resources, and make the remaining resource paths relative to the timeshared resource.
			referencePath = resourceList[timesharedIndex]["path"]
			self.definitions[name]["timeshared resource"] = resourceList[timesharedIndex]
			del resourceList[timesharedIndex]
			for i in range(len(resourceList)):
				resourceList[i]["path"] = relativatePath(referencePath, resourceList[i]["path"])
				self.maxRequest = max(self.maxRequest, resourceList[i]["require"])

		self.simulatedTime = 0

	def createResourceObjects(self, resources: dict, abstractParent, concreteParent):
		"""Build a DAG of resource objects, each resource object being a dictionary that contains subresources and/or a parent resource ("..").

		For real resources, the dictionary object also contains a data member `.throughput`.
		For each resource with a multiplicity, several equal resource objects will be created.
		For each timeshared resource, a list of the associated resource objects is created and stored under the key "resource objects"."""
		self.concreteResources = []
		for name in resources:
			curResource = resources[name]
			multiplicity = swallowExceptions(lambda: curResource["multiplicity"]) or 1
			timeshared = swallowExceptions(lambda: curResource["timeshared"]) or False
			subresources = swallowExceptions(lambda: curResource["resources"]) or None
			isResource = not throws(lambda: curResource["throughput"])

			abstractChild = swallowExceptions(lambda: abstractParent.paths[name])	#don't create abstract resources twice
			if not abstractChild: abstractChild = AbstractResource(curResource, abstractParent, name)

			for i in range(multiplicity):
				concreteChild = ResourceObject(curResource, concreteParent, name)
				abstractChild.addConcrete(concreteChild)
				self.concreteResources.append(concreteChild)
				if subresources:
					self.createResourceObjects(subresources, abstractChild, concreteChild)

		return abstractParent

	def assignResources(self, jobs: dict) -> dict:
		"""For each job, assign a key "speed" which indicates how much progress the job has per second.

		Returns the given dictionary with the updated jobs.
		Current implementation uses a quite daft, naive greedy algorithm."""
		for name in jobs:
			job = jobs[name]
			definition = self.definitions[job["name"]]

			#select an instance of the timeshared resource
			abstractTimesharedResource = resolvePath(self.resources, definition["timeshared resource"]["path"])
			allocationIndex, curThroughput = 0, -1
			for i in range(len(abstractTimesharedResource.resourceObjects)):
				if abstractTimesharedResource.resourceObjects[i].availableThroughput > curThroughput:
					allocationIndex, curThroughput = i, abstractTimesharedResource.resourceObjects[i].availableThroughput
			concreteTimesharedResource = abstractTimesharedResource.resourceObjects[i]

			#determine speed of this job
			job["speed"] = div(concreteTimesharedResource.availableThroughput, definition["timeshared resource"]["require"])
			for curRequest in definition["resources"]:
				concreteResource = resolvePath(concreteTimesharedResource, curRequest["path"])
				job["speed"] = min(job["speed"], div(concreteResource.availableThroughput, curRequest["require"]))

			#allocate the resources
			concreteTimesharedResource.availableThroughput = 0	#model busy waiting
			for curRequest in definition["resources"]:
				resolvePath(concreteTimesharedResource, curRequest["path"]).availableThroughput = job["speed"]*curRequest["require"]

			#debug output

		return jobs

	def classifyJobs(self):
		"""Build lists of executable and waiting jobs."""
		self.executableJobs = dict()
		self.waitingJobs = dict()
		for key in self.jobs:
			#do not consider jobs that are already done
			if self.jobs[key]["done"]: continue

			#determine if all precondition jobs are done
			isExecutable = True
			if swallowExceptions(lambda: len(self.jobs[key]["require"])):
				for i in range(len(self.jobs[key]["require"])):
					if not self.jobs[self.jobs[key]["require"][i]]["done"]:
						isExecutable = False
						break

			#sort the job into the appropriate class
			if isExecutable:
				self.executableJobs.update({key: self.jobs[key]});
			else:
				self.waitingJobs.update({key: self.jobs[key]});

	def simulateStep(self):
		#assign resources to the jobs and calculate their momentary speed
		self.assignResources(self.executableJobs)

		#determine how long we the jobs and their speeds will remain the same
		stepTime = math.inf
		for name in self.executableJobs:
			job = self.executableJobs[name]
			jobTime = div(1 - job["progress"], job["speed"])
			stepTime = min(stepTime, jobTime)

		#advance the simulated time
		for name in self.executableJobs:
			job = self.executableJobs[name]
			job["progress"] += stepTime*job["speed"]
			if (1-job["progress"])*self.maxRequest < 1:	#Check whether the job is done with taking float precision errors into account.
				job["progress"] = 1
				job["done"] = True
		self.simulatedTime += stepTime

		#reset the resources and redetermine the sets of executable/waiting jobs
		for resource in self.concreteResources:
			resource.availableThroughput = resource.throughput
		self.classifyJobs()

	def simulate(self):
		while self.executableJobs:
			self.simulateStep()

def main():
	options = parseArgs()
	model = Model(options.files)
	model.simulate()

main()
